diff -urN --exclude '.bzr*' libpsml-1.1.5.old/src/m_interp.F90 libpsml-1.1.5.new/src/m_interp.F90
--- libpsml-1.1.5.old/src/m_interp.F90	2017-07-27 18:54:49.000000000 +0200
+++ libpsml-1.1.5.new/src/m_interp.F90	1970-01-01 01:00:00.000000000 +0100
@@ -1,182 +0,0 @@
-module m_interp
-
-! Default quality parameter for interpolator
-integer, public, save                  :: nq = 7
-
-#ifdef __NO_PROC_POINTERS__
-
-! Use a hard-wired interpolator
-
-interface interpolator
-   module procedure dpnint1
-end interface
-
-public :: interpolator
-private :: dpnint1
-
-CONTAINS
-
-#else
-
-! This is the interface that the interpolators
-! must have
-interface
-   subroutine interpolate(nquality,x,y,npts,r,val,debug)
-
-     integer, parameter :: dp = selected_real_kind(10,100)
-
-     integer, intent(in)  :: nquality  ! Quality parameter
-     real(dp), intent(in) :: x(*), y(*)
-     integer, intent(in)  :: npts    ! Size of x, y arrays
-     real(dp), intent(in) :: r
-     real(dp), intent(out):: val
-     logical, intent(in) :: debug
-   end subroutine interpolate
-end interface
-
-! 
-procedure(interpolate),pointer, public ::  &
-                       interpolator => null()
-!
-! Note that initialization of procedure pointers at declaration
-! is a f2008 feature not yet supported by some compilers...
-!                       interpolator => dpnint1
-
-public :: set_interpolator, set_default_interpolator
-private :: dpnint1
-
-CONTAINS
-
-subroutine set_interpolator(func,nquality)
-
-! Parameter for interpolator's quality
-! It might mean different things for different
-! interpolators
-integer, intent(in) :: nquality
-
-! We should not need to repeat this...
-interface
-   subroutine func(nquality,x,y,npts,r,val,debug)
-
-     integer, parameter :: dp = selected_real_kind(10,100)
-
-     integer, intent(in)  :: nquality  ! Quality parameter
-     real(dp), intent(in) :: x(*), y(*)
-     integer, intent(in)  :: npts    ! Size of x, y arrays
-     real(dp), intent(in) :: r
-     real(dp), intent(out):: val
-     logical, intent(in) :: debug
-   end subroutine func
-end interface
-
-  interpolator => func
-  nq = nquality
-
-end subroutine set_interpolator
-
-!
-! This routine is needed to work around f2008 issue above
-!
-subroutine set_default_interpolator()
-
-! Default interpolator and quality parameter
-! DRH's dpnint modified by AG, at 7th order
-! (Included in this module with permission)
-!
-  call set_interpolator(dpnint1,7)
-
-end subroutine set_default_interpolator
-
-#endif    /* For systems without procedure pointers */
-
-!
-! Copyright (c) 1989-2014 by D. R. Hamann, Mat-Sim Research LLC and Rutgers
-! University
-! 
-! Modified by Alberto Garcia, March 2015
-! This routine is included in this module with permission from D.R. Hamann.
-!
- subroutine dpnint1(npoly, xx, yy, nn, r, val, debug)
-
-! Modified by Alberto Garcia, March 2015 from routine
-! dpnint by D.R. Hamann. 
-! Changes:
-!   -- A single value is returned
-!   -- It can extrapolate, instead of stopping,
-!      when called with an abscissa outside the
-!      data range.
-!   -- If the number of data points is less than
-!      npoly+1, npoly is implicitly reduced, without
-!      error, and without warning.
-!   -- Debug interface 
-!
-! local polynomial interpolation of data yy on nn points xx
-! giving value val on point r
-! npoly sets order of polynomial
-! xx must be ordered in ascending order
-! output interpolated value val on point r
-
- implicit none
-
- integer, parameter :: dp=kind(1.0d0)
-
-!Input variables
- real(dp), intent(in) :: xx(*),yy(*)
- real(dp), intent(in) :: r
- real(dp), intent(out) :: val
- integer, intent(in)   ::  nn,npoly
- logical, intent(in)   ::  debug
-
-!Local variables
- real(dp) :: sum,term,zz
- integer ii,imin,imax,iprod,iy,istart,kk,iend
-
-! interval halving search for xx(ii) points bracketing r
-
-   imin = 1
-   imax = nn
-   do kk = 1, nn
-     ii = (imin + imax) / 2
-     if(r>xx(ii)) then
-       imin = ii
-     else
-       imax = ii
-     end if
-     if(imax - imin .eq. 1) then
-       exit
-     end if
-   end do
-
-
-   zz=r
-
-!   if (debug) print *, "imin, imax: ", imin, imax
-
-   if(mod(npoly,2)==1) then
-    istart=imin-npoly/2
-   else if(zz-xx(imin) < xx(imax)-zz) then
-     istart=imin-npoly/2
-   else
-     istart=imax-npoly/2
-   end if
-
-   istart = min(istart, nn - npoly)
-   istart = max(istart, 1)
-   iend = min(istart+npoly,nn)
-
- !  if (debug) print *, "istart, iend: ", istart, iend
-   sum=0.0d0
-   do iy=istart,iend
-    if(yy(iy)==0.0d0) cycle
-    term=yy(iy)
-    do iprod=istart, iend
-     if(iprod==iy) cycle
-     term=term*(zz-xx(iprod))/(xx(iy)-xx(iprod))
-    end do
-    sum=sum+term
-   end do
-   val=sum
-
- end subroutine dpnint1
-
-end module m_interp
diff -urN --exclude '.bzr*' libpsml-1.1.5.old/src/m_psml_api.F90 libpsml-1.1.5.new/src/m_psml_api.F90
--- libpsml-1.1.5.old/src/m_psml_api.F90	2017-07-27 18:54:49.000000000 +0200
+++ libpsml-1.1.5.new/src/m_psml_api.F90	2017-09-19 10:18:54.339997707 +0200
@@ -116,7 +116,7 @@
      use_effective_range,&
      custom_interpolator)
 
-use m_interp, only: nq, interpolator
+use m_psml_interp, only: nq, interpolator
 
 ! Parameter for interpolator's quality
 ! It might mean different things for different
@@ -1185,7 +1185,7 @@
 
 !----------
 function eval_radfunc(f,r,debug) result(val)
-use m_interp, only: interpolator, nq
+use m_psml_interp, only: interpolator, nq
 
 type(radfunc_t), intent(in) :: f
 real(dp), intent(in)      :: r
diff -urN --exclude '.bzr*' libpsml-1.1.5.old/src/m_psml_interp.F90 libpsml-1.1.5.new/src/m_psml_interp.F90
--- libpsml-1.1.5.old/src/m_psml_interp.F90	1970-01-01 01:00:00.000000000 +0100
+++ libpsml-1.1.5.new/src/m_psml_interp.F90	2017-09-19 10:16:39.855505670 +0200
@@ -0,0 +1,182 @@
+module m_psml_interp
+
+! Default quality parameter for interpolator
+integer, public, save                  :: nq = 7
+
+#ifdef __NO_PROC_POINTERS__
+
+! Use a hard-wired interpolator
+
+interface interpolator
+   module procedure dpnint1
+end interface
+
+public :: interpolator
+private :: dpnint1
+
+CONTAINS
+
+#else
+
+! This is the interface that the interpolators
+! must have
+interface
+   subroutine interpolate(nquality,x,y,npts,r,val,debug)
+
+     integer, parameter :: dp = selected_real_kind(10,100)
+
+     integer, intent(in)  :: nquality  ! Quality parameter
+     real(dp), intent(in) :: x(*), y(*)
+     integer, intent(in)  :: npts    ! Size of x, y arrays
+     real(dp), intent(in) :: r
+     real(dp), intent(out):: val
+     logical, intent(in) :: debug
+   end subroutine interpolate
+end interface
+
+! 
+procedure(interpolate),pointer, public ::  &
+                       interpolator => null()
+!
+! Note that initialization of procedure pointers at declaration
+! is a f2008 feature not yet supported by some compilers...
+!                       interpolator => dpnint1
+
+public :: set_interpolator, set_default_interpolator
+private :: dpnint1
+
+CONTAINS
+
+subroutine set_interpolator(func,nquality)
+
+! Parameter for interpolator's quality
+! It might mean different things for different
+! interpolators
+integer, intent(in) :: nquality
+
+! We should not need to repeat this...
+interface
+   subroutine func(nquality,x,y,npts,r,val,debug)
+
+     integer, parameter :: dp = selected_real_kind(10,100)
+
+     integer, intent(in)  :: nquality  ! Quality parameter
+     real(dp), intent(in) :: x(*), y(*)
+     integer, intent(in)  :: npts    ! Size of x, y arrays
+     real(dp), intent(in) :: r
+     real(dp), intent(out):: val
+     logical, intent(in) :: debug
+   end subroutine func
+end interface
+
+  interpolator => func
+  nq = nquality
+
+end subroutine set_interpolator
+
+!
+! This routine is needed to work around f2008 issue above
+!
+subroutine set_default_interpolator()
+
+! Default interpolator and quality parameter
+! DRH's dpnint modified by AG, at 7th order
+! (Included in this module with permission)
+!
+  call set_interpolator(dpnint1,7)
+
+end subroutine set_default_interpolator
+
+#endif    /* For systems without procedure pointers */
+
+!
+! Copyright (c) 1989-2014 by D. R. Hamann, Mat-Sim Research LLC and Rutgers
+! University
+! 
+! Modified by Alberto Garcia, March 2015
+! This routine is included in this module with permission from D.R. Hamann.
+!
+ subroutine dpnint1(npoly, xx, yy, nn, r, val, debug)
+
+! Modified by Alberto Garcia, March 2015 from routine
+! dpnint by D.R. Hamann. 
+! Changes:
+!   -- A single value is returned
+!   -- It can extrapolate, instead of stopping,
+!      when called with an abscissa outside the
+!      data range.
+!   -- If the number of data points is less than
+!      npoly+1, npoly is implicitly reduced, without
+!      error, and without warning.
+!   -- Debug interface 
+!
+! local polynomial interpolation of data yy on nn points xx
+! giving value val on point r
+! npoly sets order of polynomial
+! xx must be ordered in ascending order
+! output interpolated value val on point r
+
+ implicit none
+
+ integer, parameter :: dp=kind(1.0d0)
+
+!Input variables
+ real(dp), intent(in) :: xx(*),yy(*)
+ real(dp), intent(in) :: r
+ real(dp), intent(out) :: val
+ integer, intent(in)   ::  nn,npoly
+ logical, intent(in)   ::  debug
+
+!Local variables
+ real(dp) :: sum,term,zz
+ integer ii,imin,imax,iprod,iy,istart,kk,iend
+
+! interval halving search for xx(ii) points bracketing r
+
+   imin = 1
+   imax = nn
+   do kk = 1, nn
+     ii = (imin + imax) / 2
+     if(r>xx(ii)) then
+       imin = ii
+     else
+       imax = ii
+     end if
+     if(imax - imin .eq. 1) then
+       exit
+     end if
+   end do
+
+
+   zz=r
+
+!   if (debug) print *, "imin, imax: ", imin, imax
+
+   if(mod(npoly,2)==1) then
+    istart=imin-npoly/2
+   else if(zz-xx(imin) < xx(imax)-zz) then
+     istart=imin-npoly/2
+   else
+     istart=imax-npoly/2
+   end if
+
+   istart = min(istart, nn - npoly)
+   istart = max(istart, 1)
+   iend = min(istart+npoly,nn)
+
+ !  if (debug) print *, "istart, iend: ", istart, iend
+   sum=0.0d0
+   do iy=istart,iend
+    if(yy(iy)==0.0d0) cycle
+    term=yy(iy)
+    do iprod=istart, iend
+     if(iprod==iy) cycle
+     term=term*(zz-xx(iprod))/(xx(iy)-xx(iprod))
+    end do
+    sum=sum+term
+   end do
+   val=sum
+
+ end subroutine dpnint1
+
+end module m_psml_interp
diff -urN --exclude '.bzr*' libpsml-1.1.5.old/src/m_psml_old_api.F90 libpsml-1.1.5.new/src/m_psml_old_api.F90
--- libpsml-1.1.5.old/src/m_psml_old_api.F90	2017-07-27 18:54:49.000000000 +0200
+++ libpsml-1.1.5.new/src/m_psml_old_api.F90	2017-09-19 10:16:59.143575322 +0200
@@ -120,7 +120,7 @@
 !> Sets the default interpolator and
 !> its quality parameter
 subroutine ps_SetInterpolator(func,nquality)
-use m_interp, only: interpolator, nq
+use m_psml_interp, only: interpolator, nq
 
 ! Parameter for interpolator's quality
 ! It might mean different things for different
@@ -153,7 +153,7 @@
 !> not care about the type of evaluator, but
 !> want to compare different qualities
 subroutine ps_SetInterpolatorQuality(nquality)
-use m_interp, only: nq
+use m_psml_interp, only: nq
 
 ! Parameter for interpolator's quality
 ! It might mean different things for different
@@ -964,7 +964,7 @@
 end function max_range
 !----------
 function eval_radfunc(f,r,debug) result(val)
-use m_interp, only: interpolator, nq
+use m_psml_interp, only: interpolator, nq
 
 type(radfunc_t), intent(in) :: f
 real(dp), intent(in)      :: r
diff -urN --exclude '.bzr*' libpsml-1.1.5.old/src/m_psml_reader.F90 libpsml-1.1.5.new/src/m_psml_reader.F90
--- libpsml-1.1.5.old/src/m_psml_reader.F90	2017-07-27 18:54:49.000000000 +0200
+++ libpsml-1.1.5.new/src/m_psml_reader.F90	2017-09-19 10:17:06.539602117 +0200
@@ -15,7 +15,7 @@
 
   use external_interfaces,    only: die => psml_die
 #ifndef __NO_PROC_POINTERS__
-  use m_interp,               only: set_default_interpolator
+  use m_psml_interp,               only: set_default_interpolator
 #endif
 
 #ifdef PSML_USE_FOX
diff -urN --exclude '.bzr*' libpsml-1.1.5.old/src/makefile libpsml-1.1.5.new/src/makefile
--- libpsml-1.1.5.old/src/makefile	2017-07-27 18:54:49.000000000 +0200
+++ libpsml-1.1.5.new/src/makefile	2017-09-19 10:17:17.679642566 +0200
@@ -36,7 +36,7 @@
 OBJFILES= m_psml_core.o m_psml_dump.o m_psml_api.o m_psml_tables.o\
           m_psml_parsing_helpers.o m_psml_reader.o m_psml_ps_edit.o\
           iso_varying_string.o class_grid.o m_psml_old_api.o\
-          assoc_list.o external_interfaces.o m_interp.o sets_m.o\
+          assoc_list.o external_interfaces.o m_psml_interp.o sets_m.o\
           m_psml.o m_aux_aliases.o
 #
 MODULES_TO_INSTALL=m_psml.mod m_psml_reader.mod m_psml_core.mod \
@@ -101,9 +101,9 @@
 class_grid.o: assoc_list.o
 m_psml.o: assoc_list.o m_psml_api.o m_psml_core.o m_psml_dump.o
 m_psml.o: m_psml_ps_edit.o m_psml_reader.o m_psml_old_api.o
-m_psml_api.o: assoc_list.o class_grid.o external_interfaces.o m_interp.o
+m_psml_api.o: assoc_list.o class_grid.o external_interfaces.o m_psml_interp.o
 m_psml_api.o: m_psml_core.o m_aux_aliases.o
-m_psml_old_api.o: assoc_list.o class_grid.o external_interfaces.o m_interp.o
+m_psml_old_api.o: assoc_list.o class_grid.o external_interfaces.o m_psml_interp.o
 m_psml_old_api.o: m_psml_core.o m_aux_aliases.o
 m_psml_core.o: assoc_list.o class_grid.o external_interfaces.o
 m_psml_core.o: iso_varying_string.o
@@ -112,7 +112,7 @@
 m_psml_parsing_helpers.o: assoc_list.o class_grid.o external_interfaces.o
 m_psml_parsing_helpers.o: iso_varying_string.o m_psml_core.o
 m_psml_ps_edit.o: assoc_list.o external_interfaces.o m_psml_core.o
-m_psml_reader.o: external_interfaces.o m_interp.o m_psml_core.o
+m_psml_reader.o: external_interfaces.o m_psml_interp.o m_psml_core.o
 m_psml_reader.o: m_psml_parsing_helpers.o m_psml_tables.o
 m_psml_tables.o: m_psml_core.o
 m_aux_aliases.o: m_psml_core.o
